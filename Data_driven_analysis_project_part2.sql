-- 	DATA DRIVEN ANALYSIS PROJECT PART-2

-- TASK 1 (EMPLOYEE DATA ANALYSIS)

-- 1) FIND THE TOTAL NUMBER OF EMPLOYEES

SELECT COUNT(*) FROM EMPLOYEES;

/* Interpretations: this query counts all rows in the employees table.
count(*): it counts the number of employee number.
*/

-- 2) LIST ALL EMPLOYEES WITH THEIR BASIC INFORMATION

SELECT EMPLOYEENUMBER, FIRSTNAME, LASTNAME, EMAIL, JOBTITLE FROM EMPLOYEES;

/* Interpretations: this query specifies the column names to retrieve the basic information from the 
empoyees table.
*/ 

-- 3) COUNT THE NUMBER OF EMPLOYEES HOLDING EACH JOB TITLE

SELECT JOBTITLE, COUNT(*) NO_OF_EMPLOYEES FROM EMPLOYEES GROUP BY JOBTITLE ORDER BY NO_OF_EMPLOYEES DESC; 

/* Interpretations: 
jobtitle, no_of_employees: the select command specifies the job title with the count of number of employees under each job title.
GROUP BY JOBTITLE: groups the rows based on unique job titles.
ORDER BY NO_OF_EMPLOYEES DESC:  sorts the results in descending order of the number of employees, showing the most common job titles first.
*/

-- 4) FIND THE EMPLOYEES WHO DON'T HAVE A MANAGER(REPORTSTO IS NULL)

SELECT FIRSTNAME, LASTNAME FROM EMPLOYEES WHERE REPORTSTO IS NULL;

/* Interpretations:
This query identifies employees who do not have a manager assigned to them.
WHERE REPORTSTO IS NULL: filters the employees table to include only those rows where the REPORTSTO column (which represents the employee's manager)
 has a value of NULL.
*/

-- 5) CALCULATE TOTAL SALES GENERATED BY EACH SALES REPRESENTATIVE

SELECT CUSTOMERS.SALESREPEMPLOYEENUMBER , EMPLOYEES.FIRSTNAME, EMPLOYEES.LASTNAME, SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) TOTAL_SALES
FROM EMPLOYEES LEFT JOIN CUSTOMERS ON EMPLOYEES.EMPLOYEENUMBER = CUSTOMERS.SALESREPEMPLOYEENUMBER
LEFT JOIN ORDERS ON CUSTOMERS.CUSTOMERNUMBER = ORDERS.CUSTOMERNUMBER
LEFT JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER 
GROUP BY CUSTOMERS.SALESREPEMPLOYEENUMBER, EMPLOYEES.FIRSTNAME, EMPLOYEES.LASTNAME
ORDER BY TOTAL_SALES DESC ;

/* Interpretations:
It starts with the employees table and uses LEFT JOIN to connect it with customers, orders, and orderdetails tables.
This ensures that even sales representatives with no sales are included in the result (their total sales will be 0).
The join conditions: link the tables based on the basis of the common columns/foreign keys (SALESREPEMPLOYEENUMBER, CUSTOMERNUMBER, and ORDERNUMBER).
SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH): calculates the total sales for each order by multiplying the quantity ordered by the price for each item and then summing these amounts.
GROUP BY CUSTOMERS.SALESREPEMPLOYEENUMBER, EMPLOYEES.FIRSTNAME, EMPLOYEES.LASTNAME: groups the results by sales representative, allowing the SUM() function to calculate total sales for each representative.
ORDER BY TOTAL_SALES DESC : sorts the results in descending order of total sales, showing the top performers first.
*/
 
 -- 6) FIND THE MOST PROFITABLE SALES REPRESENTATIVE BASED ON TOTAL SALES

SELECT CUSTOMERS.SALESREPEMPLOYEENUMBER , EMPLOYEES.FIRSTNAME, EMPLOYEES.LASTNAME, SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) TOTAL_SALES
FROM EMPLOYEES LEFT JOIN CUSTOMERS ON EMPLOYEES.EMPLOYEENUMBER = CUSTOMERS.SALESREPEMPLOYEENUMBER LEFT JOIN ORDERS ON CUSTOMERS.CUSTOMERNUMBER = ORDERS.CUSTOMERNUMBER
LEFT JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER GROUP BY CUSTOMERS.SALESREPEMPLOYEENUMBER, EMPLOYEES.FIRSTNAME, EMPLOYEES.LASTNAME
ORDER BY TOTAL_SALES DESC LIMIT 1;

/* Interpretations:
joins the employees, customers, orders, and orderdetails tables to link sales representatives to their customers' orders and the details of those orders.
SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH): calculates the total sales for each sales representative.
GROUP BY : groups the results by sales representative to aggregate their sales.
ORDER BY TOTAL_SALES DESC: sorts the results in descending order of total sales, placing the highest sales at the top.
LIMIT 1: restricts the result to only the first row, gives us the sales representative with the highest total sales.
*/

-- 7) FIND THE NAMES OF ALL EMPLOYEES WHO HAVE SOLD MORE THAN THE AVERAGE SALES AMOUNT FOR THEIR OFFICE

SELECT EMPLOYEES.FIRSTNAME, EMPLOYEES.LASTNAME FROM EMPLOYEES
JOIN CUSTOMERS ON EMPLOYEES.EMPLOYEENUMBER = CUSTOMERS.SALESREPEMPLOYEENUMBER
JOIN ORDERS ON CUSTOMERS.CUSTOMERNUMBER = ORDERS.CUSTOMERNUMBER
JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER
JOIN (SELECT EMPLOYEES.OFFICECODE, AVG(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) AS AVERAGE_SALES
FROM EMPLOYEES JOIN CUSTOMERS ON EMPLOYEES.EMPLOYEENUMBER = CUSTOMERS.SALESREPEMPLOYEENUMBER 
JOIN ORDERS ON CUSTOMERS.CUSTOMERNUMBER = ORDERS.CUSTOMERNUMBER
JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER
GROUP BY EMPLOYEES.OFFICECODE) AS AVERAGE_SALES_OF_OFFICES ON EMPLOYEES.OFFICECODE = AVERAGE_SALES_OF_OFFICES.OFFICECODE
WHERE (ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) > AVERAGE_SALES_OF_OFFICES.AVERAGE_SALES
GROUP BY EMPLOYEES.FIRSTNAME, EMPLOYEES.LASTNAME;

/* Interpretations:
It joins the following tables : EMPLOYEES, CUSTOMERS, ORDERS, ORDERDETAILS.
A subquery (AVERAGE_OF_OFFICES): is used to determine the average sales for each office.
The main query: compares each employee's sales with the average sales of their office using the WHERE clause.
GROUP BY EMPLOYEES.FIRSTNAME, EMPLOYEES.LASTNAME: ensures that each employee is listed only once,
even if they have multiple sales exceeding the average.
*/



-- TASK 2 (ORDER ANALYSIS)

-- 1) FIND THE AVERAGE ORDER AMOUNT FOR EACH CUSTOMER

SELECT CUSTOMERS.CUSTOMERNAME, AVG(PAYMENTS.AMOUNT) AVG_ORDER_AMOUNT FROM CUSTOMERS
JOIN PAYMENTS ON CUSTOMERS.CUSTOMERNUMBER = PAYMENTS.CUSTOMERNUMBER
GROUP BY CUSTOMERS.CUSTOMERNUMBER ORDER BY AVG_ORDER_AMOUNT DESC;

/* Interpretations:
this query uses a JOIN without specifying the type,
which defaults to an INNER JOIN. This means it will only include customers who have made at least one payment.
*/

-- 2) FIND THE NUMBER OF ORDERS PLACED IN EACH MONTH

SELECT MONTHNAME(ORDERS.ORDERDATE) MONTH, COUNT(ORDERS.ORDERNUMBER) NUMBER_OF_ORDERS
FROM ORDERS GROUP BY MONTH ORDER BY NUMBER_OF_ORDERS DESC;

/* Interpretations:
MONTHNAME(ORDERS.ORDERDATE): Extracts the month name from the ORDERDATE column.
COUNT(ORDERS.ORDERNUMBER): Counts the number of orders for each month.
GROUP BY MONTH: Groups the results by month name.
ORDER BY NUMBER_OF_ORDERS DESC: Sorts the results by the number of orders in descending order.
*/

-- 3) IDENTIFY ORDERS THAT ARE STILL PENDING SHIPMENT (STATUS = 'PENDING')

SELECT PRODUCTS.PRODUCTNAME, ORDERS.STATUS FROM ORDERS LEFT JOIN ORDERDETAILS
ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER LEFT JOIN PRODUCTS 
ON ORDERDETAILS.PRODUCTCODE = PRODUCTS.PRODUCTCODE WHERE ORDERS.STATUS = "ON HOLD"
OR ORDERS.STATUS = "IN PROCESS";

/* Interpretaions:
It joins the ORDERS, ORDERDETAILS, and PRODUCTS tables to retrieve product names and order statuses.
where clause: filters the records on the basid of the status.
*/


-- 4) LIST ORDERS ALONG WITH CUSTOMER DETAILS

SELECT ORDERS.ORDERNUMBER, CUSTOMERS.CUSTOMERNAME, CUSTOMERS.PHONE,
SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) TOTAL_SALES FROM CUSTOMERS
JOIN ORDERS ON CUSTOMERS.CUSTOMERNUMBER = ORDERS.CUSTOMERNUMBER JOIN ORDERDETAILS
ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER GROUP BY ORDERS.ORDERNUMBER, CUSTOMERS.CUSTOMERNAME, CUSTOMERS.PHONE;

/* Interpretations:
It joins the CUSTOMERS, ORDERS, and ORDERDETAILS tables to link customers to their orders and the items in those orders.
SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH): calculates the total sales for each order.
GROUP BY ORDERS.ORDERNUMBER, CUSTOMERS.CUSTOMERNAME, CUSTOMERS.PHONE: groups the results by order number, customer name, and customer
 phone so that the SUM() function calculates the total sales for each unique combination of these fields.
*/

-- 5) RETRIEVE THE MOST RECENT ORDERS (BASED ON ORDER DATE)

SELECT ORDERNUMBER, ORDERDATE FROM ORDERS ORDER BY ORDERDATE DESC LIMIT 10;

/* Interpretations:
This query retrieves the 10 most recent orders based on the order date.
ORDER BY ORDERDATE DESC: Sorts the orders in descending order of the ORDERDATE column, putting the most recent orders first.
LIMIT 10: Restricts the result set to the first 10 rows, giving us the 10 most recent orders.
*/

-- 6) CALCULATE TOTAL SALES FOR EACH ORDER 

SELECT ORDERS.ORDERNUMBER, SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) TOTAL_SALES
FROM ORDERS JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER 
GROUP BY ORDERS.ORDERNUMBER ;

/* Interpretations:
It joins the ORDERS and ORDERDETAILS tables to access order information and the details of the items in each order.
SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH): calculates the total sales for each order by multiplying the quantity ordered by the price
for each item and summing those amounts.
GROUP BY ORDERS.ORDERNUMBER: groups the results by order number, so that the SUM() function calculates the total sales for each distinct order.
*/

-- 7) FIND THE HIGHEST VALUE ORDER BASED ON TOTAL SALES

SELECT ORDERS.ORDERNUMBER, SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) TOTAL_SALES
FROM ORDERS LEFT JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER 
GROUP BY ORDERS.ORDERNUMBER ORDER BY TOTAL_SALES DESC LIMIT 1;

/* Interpretations:
It joins the ORDERS and ORDERDETAILS tables to link orders to their respective items and prices.
SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH): calculates the total sales for each order.
GROUP BY ORDERS.ORDERNUMBER: groups the results by order number to calculate the sum for each order.
ORDER BY TOTAL_SALES DESC: sorts the results in descending order of total sales.
LIMIT 1:restricts the output to the single row representing the highest value order.
*/

-- 8) LIST ALL ORDERS WITH THEIR CORRESPONDING ORDER DETAILS

SELECT ORDERS.ORDERNUMBER, ORDERS.ORDERDATE, ORDERS.STATUS, SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) TOTAL_SALES
FROM ORDERS LEFT JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER GROUP BY ORDERS.ORDERNUMBER;

/* Interpretations:
It joins the ORDERS and ORDERDETAILS tables.
SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH): calculates the total sales for each order.
GROUP BY ORDERS.ORDERNUMBER: groups the results by order number, so the SUM() function aggregates sales for each order.
The query effectively provides a summary of each order, including its number, date, status, and total sales.
*/

-- 9) LIST THE MOST FREQUENTLY ORDERED PRODUCTS

SELECT PRODUCTS.PRODUCTNAME, COUNT(PRODUCTS.PRODUCTCODE) MOST_ORDERED_PRODUCT FROM PRODUCTS
LEFT JOIN ORDERDETAILS ON PRODUCTS.PRODUCTCODE = ORDERDETAILS.PRODUCTCODE
GROUP BY PRODUCTS.PRODUCTNAME ORDER BY MOST_ORDERED_PRODUCT DESC LIMIT 10;

/* Interpretations:
It joins the PRODUCTS and ORDERDETAILS tables to link products to their order details.
COUNT(PRODUCTS.PRODUCTCODE): counts the number of times each product was appeared in the ORDERDETAILS table.
GROUP BY PRODUCTS.PRODUCTNAME: groups the results by product name to get the count for each product.
ORDER BY MOST_ORDERED_PRODUCT DESC: sorts the results by the count in descending order.
LIMIT 10: restricts the output to the top 10 most frequently ordered products.
*/

-- 10) CALCULAT TOTAL REVENUE FOR EACH ORDER

SELECT ORDERS.ORDERNUMBER , SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) TOTAL_REVENUE
FROM ORDERS LEFT JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER 
GROUP BY ORDERS.ORDERNUMBER ;

/* Interpretations:
It joins the ORDERS and ORDERDETAILS tables.
SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH): calculates the total revenue for each order.
GROUP BY ORDERS.ORDERNUMBER: groups the results by order number.
*/

-- 11) IDENTIFY THE MOST PROFITABLE ORDERS BASED ON TOTAL REVENUE

SELECT ORDERS.ORDERNUMBER , SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) TOTAL_REVENUE
FROM ORDERS LEFT JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER 
GROUP BY ORDERS.ORDERNUMBER ORDER BY TOTAL_REVENUE DESC LIMIT 5;

/* Interpretations:
It joins the ORDERS and ORDERDETAILS tables.
SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH): calculates the total revenue for each order.
GROUP BY ORDERS.ORDERNUMBER: groups the results by order number.
ORDER BY TOTAL_REVENUE DESC: sorts the results in descending order of total revenue.
LIMIT 5: restricts the output to the top 5 orders.
*/

-- 12) LIST ALL ORDERS WITH DETAILED PRODUCT INFORMATION

SELECT ORDERS.ORDERNUMBER, ORDERS.ORDERDATE, CUSTOMERS.CUSTOMERNAME, PRODUCTS.PRODUCTCODE, PRODUCTS.PRODUCTNAME, 
PRODUCTS.PRODUCTLINE FROM ORDERS INNER JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER 
INNER JOIN PRODUCTS ON ORDERDETAILS.PRODUCTCODE = PRODUCTS.PRODUCTCODE 
INNER JOIN CUSTOMERS ON ORDERS.CUSTOMERNUMBER = CUSTOMERS.CUSTOMERNUMBER;

/* Interpretations:
It joins the ORDERS, ORDERDETAILS, PRODUCTS, and CUSTOMERS tables.
It selects specific columns to retrieve from different tables
inner join: joining following tables, orders, orderdetails and customers.
*/

-- 13) IDENTIFY ORDERS WITH DELAYED SHIPPING (SHIPPED DATE > REQUIRED DATE)

SELECT * FROM ORDERS WHERE SHIPPEDDATE > REQUIREDDATE;

/* Interpretations:
This query identifies orders that were shipped late (i.e., the SHIPPEDDATE is after the REQUIREDDATE).
It selects all columns from the ORDERS table.
WHERE SHIPPEDDATE > REQUIREDDATE: filters the results to include only orders where the shipped date is later than the required date.
*/

-- 14) FIND THE MOST POPULAR PRODUCT COMBINATIONS WITHIN ORDERS

SELECT OD1.PRODUCTCODE AS PRODUCT1, OD2.PRODUCTCODE AS PRODUCT2, COUNT(*) AS COMBINATION_COUNT
FROM ORDERDETAILS OD1 JOIN ORDERDETAILS OD2 ON OD1.ORDERNUMBER = OD2.ORDERNUMBER
AND OD1.PRODUCTCODE < OD2.PRODUCTCODE GROUP BY OD1.PRODUCTCODE, OD2.PRODUCTCODE
ORDER BY COMBINATION_COUNT DESC LIMIT 10;

/* Interpretations:
It joins the ORDERDETAILS table to itself (aliased as OD1 and OD2) using a self join.
ON OD1.ORDERNUMBER = OD2.ORDERNUMBER ensures that we are looking at products within the same order.
AND OD1.PRODUCTCODE < OD2.PRODUCTCODE prevents counting the same combination twice.
COUNT(*) as Combination_Count: counts the number of times each product combination appears.
GROUP BY OD1.PRODUCTCODE, OD2.PRODUCTCODE: groups the results by product combinations.
ORDER BY COMBINATION_COUNT DESC: sorts the results by frequency in descending order.
LIMIT 10: restricts the output to the top 10 combinations.
*/

-- 15) CALCULATE REVENUE FOR EACH ORDER AND IDENTIFY THE TOP 10 MOST PROFITABLE

SELECT ORDERS.ORDERNUMBER , SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) TOTAL_REVENUE
FROM ORDERS LEFT JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER 
GROUP BY ORDERS.ORDERNUMBER ORDER BY TOTAL_REVENUE DESC LIMIT 10 ;

/* Interpretations:
SELECT ORDERS.ORDERNUMBER, SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH) AS TOTAL_REVENUE: This selects the order number and calculates the total revenue for each order.

SUM(ORDERDETAILS.QUANTITYORDERED * ORDERDETAILS.PRICEEACH): calculates the revenue for each item in an order (quantity multiplied by price) 
and then sums these amounts to get the total revenue for the order.
FROM ORDERS LEFT JOIN ORDERDETAILS ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER: This joins the ORDERS table with the ORDERDETAILS table.
LEFT JOIN: ensures that all orders are included in the result, even if they don't have any associated order details (in which case the total revenue will be NULL). If you only wanted to include orders that do have details, you could use INNER JOIN.
ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER: specifies how the tables are related; the ORDERNUMBER column is the link between them.
GROUP BY ORDERS.ORDERNUMBER: This groups the results by order number. This is essential because we are using the aggregate function SUM().  The SUM() function calculates the total revenue for each group (i.e., for each order).
ORDER BY TOTAL_REVENUE DESC: This sorts the results in descending order based on the TOTAL_REVENUE.  The most profitable orders will be at the top.
LIMIT 10: This limits the result set to the top 10 rows. Since the results are sorted by total revenue, this effectively gives you the 10 most profitable orders.
*/

-- 16) CREATE A TRIGGER THAT AUTOMATICALLY UPDATES A CUSTOMERS CREDIT LIMIT AFTER A NEW ORDER IS PLACED , REDUCING IT BY THE ORDER TOTAL

DELIMITER //
CREATE TRIGGER UPDATE_CUSTOMER_CREDIT_LIMIT 
AFTER INSERT ON ORDERS
FOR EACH ROW 
BEGIN
     DECLARE ORDER_TOTAL INT ;
     
     SELECT SUM(QUANTITYORDERED * PRICEEACH) INTO ORDER_TOTAL FROM ORDERDETAILS
     WHERE ORDERNUMBER = NEW.ORDERNUMBER ;
     
     UPDATE CUSTOMERS 
     SET CREDITLIMIT = CREDITLIMIT - ORDER_TOTAL
     WHERE CUSTOMERNUMBER = NEW.CUSTOMERNUMBER;

END //
DELIMITER ;

INSERT INTO ORDERS (ORDERNUMBER, ORDERDATE, REQUIREDDATE, SHIPPEDDATE, STATUS, COMMENTS, CUSTOMERNUMBER)
VALUES (10099, "2025-08-27", "2025-09-02", "2025-08-30", "SHIPPED", "NEW ORDER", 462);

SELECT CREDITLIMIT FROM CUSTOMERS WHERE CUSTOMERNUMBER = 462;

/* Interpretations:
This code defines a trigger named UPDATE_CUSTOMER_CREDIT_LIMIT.Triggers are special stored procedures that automatically execute in response to certain events on a database table.
CREATE TRIGGER UPDATE_CUSTOMER_CREDIT_LIMIT: This creates the trigger.
AFTER INSERT ON ORDERS: This specifies that the trigger should execute after a new row is inserted into the ORDERS table.
FOR EACH ROW: This indicates that the trigger should execute once for each row that is inserted. 
BEGIN ... END: This block contains the code that the trigger will execute.
DECLARE ORDER_TOTAL INT;: This declares a local variable ORDER_TOTAL to store the total amount of the order.
SELECT SUM(QUANTITYORDERED * PRICEEACH) INTO ORDER_TOTAL FROM ORDERDETAILS WHERE ORDERNUMBER = NEW.ORDERNUMBER: This calculates the total amount of the order
by summing the product of QUANTITYORDERED and PRICEEACH from the ORDERDETAILS table for the newly inserted order.
NEW.ORDERNUMBER: refers to the ORDERNUMBER of the newly inserted row in the ORDERS table. The calculated sum is stored in the ORDER_TOTAL variable.
UPDATE CUSTOMERS SET CREDITLIMIT = CREDITLIMIT - ORDER_TOTAL WHERE CUSTOMERNUMBER = NEW.CUSTOMERNUMBER: This updates the CREDITLIMIT of the customer who placed the order.
NEW.CUSTOMERNUMBER refers to the CUSTOMERNUMBER of the customer in the newly inserted row in the ORDERS table. The customer's credit limit is reduced by the ORDER_TOTAL.
*/

-- 17) CREATE A TRIGGER THAT LOGS PRODUCT QUANTITY CHANGES WHENEVER AN ORDER DETAIL IS INSERTED OR DELETED

CREATE TABLE PRODUCT_QUANTITY_LOG 
(LOG_ID INT AUTO_INCREMENT PRIMARY KEY, PRODUCTCODE VARCHAR(15), OLD_QUANTITY INT, NEW_QUANTITY INT,
CHANGE_TYPE ENUM('INSERT', 'UPDATE'), CHANGE_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP);

-- CREATING THE TRIGGER

DELIMITER //

CREATE TRIGGER LOG_PRODUCT_QUANTITY_CHANGE
AFTER INSERT ON ORDERDETAILS
FOR EACH ROW
BEGIN
    DECLARE OLD_QUANTITY INT;

    -- Get the current stock quantity before the change
    
    SELECT QUANTITYINSTOCK INTO OLD_QUANTITY FROM PRODUCTS WHERE PRODUCTCODE = NEW.PRODUCTCODE;

    -- Update the product quantity
    
    UPDATE PRODUCTS
    SET QUANTITYINSTOCK = QUANTITYINSTOCK - NEW.QUANTITYORDERED
    WHERE PRODUCTCODE = NEW.PRODUCTCODE;

    -- Log the change
    INSERT INTO PRODUCT_QUANTITY_LOG (PRODUCTCODE, OLD_QUANTITY, NEW_QUANTITY, CHANGE_TYPE)
    VALUES (NEW.PRODUCTCODE, OLD_QUANTITY, OLD_QUANTITY - NEW.QUANTITYORDERED, 'INSERT');
END //

DELIMITER ;

INSERT INTO ORDERDETAILS VALUES (10099,"S10_1678",50,136.00,4);

UPDATE ORDERDETAILS SET QUANTITYORDERED = 55 WHERE ORDERNUMBER = 10099;



/* Interpretations:
CREATE TRIGGER PRODUCT_QUANTITY_LOGS_CHANGE: Creates a trigger named LOG_PRODUCT_QUANTITY_CHANGE.
AFTER INSERT ON ORDERDETAILS: Specifies that this trigger will execute after a new row is inserted into the ORDERDETAILS table.
FOR EACH ROW: Indicates that the trigger will execute for each row inserted (in this case, typically one row at a time).
BEGIN ... END: Encloses the trigger's code.
INSERT INTO PRODUCT_QUANTITY_LOGS: It inserts a new row into the PRODUCT_QUANTITY_LOGS table.
ORDERNUMBER: The ORDERNUMBER from the newly inserted ORDERDETAILS row (NEW.ORDERNUMBER).
PRODUCTCODE: The PRODUCTCODE from the newly inserted ORDERDETAILS row (NEW.PRODUCTCODE).
OLDQUANTITY: For an insert, the old quantity is 0, so it logs 0.
NEWQUANTITY: The QUANTITYORDERED from the newly inserted ORDERDETAILS row (NEW.QUANTITYORDERED).
*/


/*
Project Summary

This analysis is based on SQL queries executed on a business database to extract valuable insights regarding customers, employees, orders, and product performance.
 The project is divided into two parts:

-- Project Part 1: Customer and Sales Analysis

-- Top 10 Customers by Credit Limit

Identified high-value customers based on their credit limits.

Helps in determining potential for upselling and premium service offerings.

-- Total Orders Placed by Each Customer

Showed customer order frequency, which helps in identifying loyal customers.

-- Top 5 Products by Sales Revenue

Highlighted best-selling products to focus marketing and inventory management efforts.

-- Sales Performance Analysis

Identifying the top sales representatives based on revenue generated.

Analyzing order trends by month and year to identify peak sales periods.

-- Average Payment Amount by Customer

Provided insights into customer spending behavior, useful for personalized promotions.

-- Most Popular Product Category

Determined which product category generates the most sales, assisting in product development strategies.

-- Profitability and Revenue Insights

Determining the total revenue per product line.

Identifying the most profitable customer segment.

-- Conclusions
Customer Insights: The analysis helps in identifying high-value customers based on credit limit, which can guide targeted marketing strategies.
Sales Trends: Understanding sales performance by product and time period can assist in demand forecasting and inventory management.
Revenue Optimization: The insights on product profitability and sales representative performance can be leveraged for sales strategy refinement.
Actionable Decisions: Businesses can use this data to focus on high-revenue products, allocate resources effectively, and improve overall profitability.

-- Project Part 2: Employee and Order Analysis

-- Total Number of Employees

Provided an overview of workforce strength for HR and resource planning.

-- List of Employees with Basic Information

Established a structured employee database for effective personnel management.

-- Count of Employees by Job Title

Analyzed workforce distribution to assess staffing needs and organizational hierarchy.

-- Monthly Order Trends

Examined order volume trends over time, useful for demand forecasting.

-- Average Order Value

Measured revenue efficiency per order to optimize pricing strategies.

-- Top 5 Customers by Total Payments

Identified key revenue-generating customers, supporting VIP customer programs and loyalty incentives.

-- Employees without managers were identified, which may indicate top-level executives.
-- Sales representatives were analyzed based on total sales generated, with the most profitable representative highlighted.
-- Employees whose sales exceeded their office’s average sales were listed, showcasing high performers.

-- Final Business Conclusions

Based on the above analysis, the following key conclusions and recommendations can be made:

-- Customer-Centric Strategies

High-credit customers should be prioritized for premium services and loyalty programs.

Personalized marketing campaigns should be developed for frequent buyers to increase retention.

-- Product Optimization

The best-selling products and categories should be given higher priority in inventory management.

Underperforming products should be re-evaluated or phased out.

-- Sales and Order Management

Monthly order trends indicate seasonal demand fluctuations, allowing for better inventory stocking.

Enhancing customer engagement for low-frequency buyers can improve overall revenue.

-- Employee and Workforce Efficiency

Job title analysis helps optimize workforce planning and role distribution.

The employee database supports better internal communication and HR planning.

-- Financial Strategy and Growth

Understanding average payment trends and order values aids in refining pricing models.

High-paying customers should be rewarded with special discounts or early access to new products.

-- Final Recommendation:

To sustain growth and profitability, the company should leverage data-driven decision-making by continuously analyzing customer behavior,
product performance, employee efficiency, and financial trends. 

Implementing targeted strategies based on these insights will help improve
customer satisfaction,sales performance, and overall business efficiency.

*/











